/**<p> This API provides SMS, MMS, Email and InstantMessaging sending, receiving and searching functionality.</p> 
 * \name Messaging API
 *
 * The messaging API provides access to the following capabilities:
 *  Sending messages through different technologies: SMS, MMS, Email and Instant Messages.
 *  Search for messages in the different folders.
 *  Subscribe for being notified upon incoming message events.
 *
 * This API is a read only API that does not allow message or folder management.
 * 
 *
 * \def-api-feature http://webinos.org/api/messaging
 * Access to the full Messaging module except the methods Messaging.sendMessage and Messaging.find and the attribute Message.attachments 
 *
 * \def-api-feature http://webinos.org/api/messaging.send
 * Access to the Messaging.sendMessage() method 
 *
 * \def-api-feature http://webinos.org/api/messaging.find
 * Access to the Messaging.findMessages method 
 *
 * \def-api-feature http://webinos.org/api/messaging.subscribe
 * Access to the Messaging.onSMS, Messaging.onMMS, Messaging.onEmail, Messaging.onIM methods 
 *
 * \def-api-feature http://webinos.org/api/messaging.attach
 * Access to the Message.attachments attribute. 
 *
 * \author WAC 2.0 Proposed Release Version (PRV) 28 January 2011
 * \author Extended with InstantMessaging functionality for webinos by Christian Fuhrhop &lt;christian.fuhrhop@fokus.fraunhofer.de&gt;
 * \version 1.0
 */
 

 /**
   * \brief Sequence of Message objects
   */
  typedef sequence<Message> MessageArray;

   /**
    * \brief     Array of files 
    */
   typedef File[]  FileArray;



/**
 * \brief Defines what is instantiated in the deviceapis object 
 *
 * When the messaging feature is instantiated, the messaging object is available in the deviceapis object. 
 */
  [NoInterfaceObject] interface DeviceapisMessaging {
    readonly attribute Messaging messaging;
  };
  Deviceapis implements DeviceapisMessaging;
  
 /**
 * \brief Messaging creation, sending and reading capabilities 
 *
 * This interface allows a web application to create a message through the createMessage() method that returns an instance of the Message interface. That message could be manipulated through the functionality offered by the Message interface and sent afterwards through the sendMessage() method.
 *
 * Messages created through this API are not persistent in device memory until the implementation tries to send them through the send operation. When that operation has been performed, the message will be available on the relevant folder depending on the result of the operation (e.g. sent, drafts...). The only way to access the messages that have been sent is through the use of the findMessages method. The findMessages method allows developers to retrieve the content of the messages available in 
 * the device folders.
 *
 * This interface also offers mechanism to subscribe for being notified upon incoming message events.
 *
 * \code
 *  // Define the success callback
 * function messageSent() {
 *   alert("The SMS has been sent");
 * }
 * 
 * // Define the error callback
 * function messageFailed(error) {
 *   alert("The SMS could not be sent " + error.message);
 * }
 * 
 * // SMS sending example
 * var msg = deviceapis.messaging.createMessage(deviceapis.messaging.TYPE_SMS);
 * msg.body = "I will arrive in 10 minutes";
 * msg.to = ["+34666666666"];
 * 
 * // Send request
 * deviceapis.messaging.sendMessage(messageSent, messageFailed, msg);
 * \endcode
 */
   
  [NoInterfaceObject] interface Messaging {
   /**
    * \brief Identifier for messages of type SMS. 
    */  
    const short TYPE_SMS = 1;
   /**
    * \brief Identifier for messages of type MMS. 
    */     
    const short TYPE_MMS = 2;
   /**
    * \brief Identifier for messages of type Email. 
    */      
    const short TYPE_EMAIL = 3;
   /**
    * \brief Identifier for messages of type IM. 
    */      
    const short TYPE_IM = 4;
   /**
    * \brief Identifier for the message inbox.
    */  
    const unsigned short FOLDER_INBOX = 1;
   /**
    * \brief Identifier for the message outbox. 
    */      
    const unsigned short FOLDER_OUTBOX = 2;
   /**
    * \brief Identifier for the message draft folder. 
    */      
    const unsigned short FOLDER_DRAFTS = 3;
   /**
    * \brief Identifier for message sent-items folder. 
    */     
    const unsigned short FOLDER_SENTBOX = 4;
  
   /**
   * \brief Create a message of a given type. 
   *
   * \code
   * var msg = deviceapis.messaging.createMessage(deviceapis.messaging.TYPE_SMS);
   * msg.body = "WAC first SMS message.";
   * \endcode
   *
   * Throws DeviceAPIError INVALID_VALUES_ERR if the input parameter contains an invalid value. 
   *
   * Throws DeviceAPIError TYPE_MISMATCH_ERR if the input parameter is not compatible with the expected type for that parameter. 
   *
   * \param type The type of message that is created. The possible values are: TYPE_SMS, TYPE_MMS, TYPE_EMAIL and TYPE_IM. 
   * \return A Message object of the given type or null if there is any problem during the message creation. 
   */
    Message createMessage(short type);
                         

   /**
   * \brief Attempt to send the specified message. 
   *
   * If the message type is set to email and the user has multiple email accounts set up, the runtime SHOULD use the default e-mail account. If no account has been set up, the runtime MAY either provide respective mechanisms to create a new one or throw the given ErrorCallback back to the requesting widget.
   *
   * Only the parameters supported by a specific technology and that can be set up by the developer (see Message interface attribute definition) are sent as specified in the following table (the rest are ignored):
   *
   * <table>
   * <tr><td>Attribute</td><td>SMS</td><td>MMS</td><td>Email</td><td>IM</td></tr>
   *    <tr><td>to              </td><td>Yes     </td><td>Yes     </td><td>Yes     </td><td>Yes</td></tr>
   *    <tr><td>body           </td><td> Yes     </td><td>Yes     </td><td>Yes     </td><td>Yes</td></tr>
   *    <tr><td>subject         </td><td>No      </td><td>Yes     </td><td>Yes     </td><td>No</td></tr>
   *    <tr><td>attachments     </td><td>No      </td><td>Yes     </td><td>Yes     </td><td>No</td></tr>
   *    <tr><td>cc              </td><td>No      </td><td>No      </td><td>Yes     </td><td>Yes</td></tr>
   *    <tr><td>bcc             </td><td>No      </td><td>No      </td><td>Yes     </td><td>Yes</td></tr>
   *    <tr><td>priority        </td><td>No      </td><td>No      </td><td>Yes     </td><td>No</td></tr>
   * </table>
   *
   * When a message has been successfully or unsuccessfully sent, it will be stored in the relevant folder (e.g. sent folder if successfully sent). Please not that some platforms may store multiple copies of the message if multiple recipients were included.
   * 
   * When the operation is fully completed (i.e. the implementation knows the result of the send operation to all the recipients), the onsuccess method of the successCallback will be invoked if the message is successfully sent to all the recipients.
   * 
   * If any of the input parameters is not compatible with the expected type for that parameter a DeviceAPIError with code TYPE_MISMATCH_ERR MUST be synchronously thrown.
   *
   * If the operation fails for any other reason, the errorCallback will be invoked with an appropriate error code amongst the following:
   * 
   * INVALID_VALUES_ERR: If any of the input paramters contains an invalid value. E.g. successCallback or message is null, message contains invalid values in any of its attributes... Please note that in order to allow developer ignore errors errorCallback accepts null as a valid value.
   *
   * NOT_SUPPORTED_ERR: If the specified messaging technology is not supported.
   *
   * SECURITY_ERR: If the operation is not allowed.
   *
   * UNKNOWN_ERR: In any other error case.
   *
   * If the errorCallback does not contain a valid function (e.g. null), case of any error that should be returned in the errorCallback (see above), the implementation MUST silently fail and no further action is required (i.e. the error is not notified to the developer).
   *
   * \code
   * // Define the success callback
   * function messageSent() {
   * alert("The SMS has been sent to all the recipients");
   * }
   * 
   * // Define the error callback
   * function messageFailed(error) {
   * alert("The SMS could not be sent " + error.message);
   * }
   * 
   * // SMS sending example
   * var msg = deviceapis.messaging.createMessage(deviceapis.messaging.TYPE_SMS);
   * msg.body = "I will arrive in 10 minutes";
   * msg.to = ["+34666666666", "+34888888888"];
   * 
   * // Send request
   * deviceapis.messaging.sendMessage(messageSent, messageFailed, msg);
   * \endcode
   *
   * Throws DeviceAPIError TYPE_MISMATCH_ERR if any input parameter is not compatible with the expected type for that parameter. 
   *
   * \param successCallback To be invoked if the message is successfully sent. 
   * \param errorCallback To be invoked in case the sending request fails. 
   * \param message The message to be sent. 
   * \return PendingOperation to cancel the asynchronous call 
   */                          
    PendingOperation sendMessage(SuccessCallback successCallback, 
                                 ErrorCallback errorCallback, 
                                 Message message);
 
                                 
   /**
   * \brief Gets an array of messages from the message folders matching the selected filter. 
   *
   * If any of the input parameters is not compatible with the expected type for that parameter a DeviceAPIError with code TYPE_MISMATCH_ERR MUST be synchronously thrown.
   *
   * If the this feature is not supported, a DeviceAPIError with code NOT_SUPPORTED_ERR MUST be returned in the errorCallback. If this functionality is not allowed the errorCallback MUST be invoked with a DeviceAPIError with code SECURITY_ERR.
   *
   * If the successCallback does not contain a Function (i.e. it is null), a DeviceAPIError with code INVALID_VALUES_ERR MUST be returned.
   *
   * If the filter is passed and contains valid values, only those values in the message lists that matches the filter criteria as specified in the MessageFilter interface will be returned in the successCallback. If no filter is passed, it is null or undefined, or contains any invalid value, the implementation MUST return the full list of messages in the successCallback. If no messages are available in the lists or no one matches the filter criteria, the successCallback will be invoked with an empty array.
   *
   * If any other error occurs, while trying to retrieve the messages, the errorCallback function that was passed in the invocation MUST be called including a DeviceAPIError object with code UNKNOWN_ERR.
   *
   * In any of the cases in which the errorCallback should be invoked, if the developer has not passed an ErrorCallback or it is null, no action is required (i.e. the error is not notified to the developer).
   *
   * \code
   *    var msg = { type:[deviceapis.messaging.TYPE_SMS], body:"first messa%" };
   *
   * deviceapis.messaging.findMessages(
   *    function (messages) {
   *      alert(messages.length + " message(s) found!");
   *      for (var i=0; i<messages.length; i++) {
   *        alert(i + ". message from " + messages[i].from);
   *      }
   *    }, 
   *   null, 
   *   msg);
   * \endcode
   *
   * Throws DeviceAPIError TYPE_MISMATCH_ERR if any input parameter is not compatible with the expected type for that parameter. 
   * 
   * \param successCallback function called when the invocation ends successfully. 
   * \param errorCallback function called when an error occurs 
   * \param filter message data to be used when filtering 
   * \return PendingOperation to cancel the asynchronous call 
   */                          

    PendingOperation findMessages(FindMessagesSuccessCallback successCallback, 
                                  optional ErrorCallback errorCallback,
                                  optional MessageFilter filter);
  
   /**
   * \brief Registers the function to be notified on incoming new SMSs 
   *
   * When this method is invoked, the implementation MUST register the function passed in the messageHandler argument as the handler for being notified whenever an incoming SMS arrives to the device. That function will be invoked every time an incoming SMS arrives, unless the unsubscribe method with the handler identifier is invoked in order to cancel the subscription.
   *
   * If the subscription is successfully created, an identifier for the handler is created and returned so that it is possible to cancel the subscription. If the subscription cannot be created, a DeviceAPIError is synchronously thrown with an error code that describes the reason for the error.If any of the input parameters is not compatible with the expected type for that parameter a DeviceAPIError with code TYPE_MISMATCH_ERR MUST be synchronously thrown.
   *
   * \code
   *  // function to receive new SMS notifications
   *  function incomingSMS(message)
   *  {
   *    alert("New incoming SMS from " + message.from);
   * 
   *    // The subscription is cancelled to prevent further notifications
   *    if (mySMSListener != null)
   *      deviceapis.messaging.unsubscribe(mySMSListener);
   *  }
   * \endcode
   *
   * Throws DeviceAPIError SECURITY_ERR if this operation is not allowed. 
   *
   * Throws DeviceAPIError NOT_SUPPORTED_ERR if this feature is not supported. 
   *
   * Throws DeviceAPIError INVALID_VALUES_ERR if the messageHandler is null or undefined. 
   *
   * Throws DeviceAPIError TYPE_MISMATCH_ERR if any input parameter is not compatible with the expected type for that parameter. 
   *
   * \param messageHandler The function to be invoked on incoming SMSs 
   * \return Subscription identifier 
   */                          
    unsigned long onSMS(OnIncomingMessage messageHandler);
                     

   /**
   * \brief Registers the function to be notified on incoming new MMSs 
   *
   * When this method is invoked, the implementation MUST register the function passed in the messageHandler argument as the handler for being notified whenever an incoming MMS arrives to the device. That function will be invoked every time an incoming MMS arrives, unless the unsubscribe method with the handler identifier is invoked in order to cancel the subscription.
   *
   * If the subscription is successfully created, an identifier for the handler is created and returned so that it is possible to cancel the subscription. If the subscription cannot be created, a DeviceAPIError is synchronously thrown with an error code that describes the reason for the error.
   *
   * \code
   * // function to receive new MMS notifications
   * function incomingMMS(message)
   * {
   *   alert("New incoming MMS from " + message.from);
   *
   *   // The subscription is cancelled to prevent further notifications
   *   if (myMMSListener != null)
   *     deviceapis.messaging.unsubscribe(myMMSListener);
   * }
   * \endcode
   *
   * Throws DeviceAPIError SECURITY_ERR if this operation is not allowed. 
   *
   * Throws DeviceAPIError NOT_SUPPORTED_ERR if this feature is not supported. 
   *
   * Throws DeviceAPIError INVALID_VALUES_ERR if the messageHandler is null or undefined. 
   *
   * Throws DeviceAPIError TYPE_MISMATCH_ERR if any input parameter is not compatible with the expected type for that parameter. 
   *
   * \param messageHandler The function to be invoked on incoming MMSs 
   * \return Subscription identifier 
   */                          
    unsigned long onMMS(OnIncomingMessage messageHandler) ;

   /**
   * \brief Registers the function to be notified on incoming new Email
   *
   * When this method is invoked, the implementation MUST register the function passed in the messageHandler argument as the handler for being notified whenever an incoming Email arrives to the device. That function will be invoked every time an incoming Email arrives, unless the unsubscribe method with the handler identifier is invoked in order to cancel the subscription.
   *
   * If the subscription is successfully created, an identifier for the handler is created and returned so that it is possible to cancel the subscription. If the subscription cannot be created, a DeviceAPIError is synchronously thrown with an error code that describes the reason for the error.
   *
   * \code
   * // function to receive new Email notifications
   *  function incomingEmail(message)
   *  {
   *    alert("New incoming Email from " + message.from);
   * 
   *    // The subscription is cancelled to prevent further notifications
   *    if (myEmailListener != null)
   *      deviceapis.messaging.unsubscribe(myEmailListener);
   *  }
   * 
   *  // Register listener for new Email events
   *  var myEmailListener = null;
   *  myEmailListener = deviceapis.messaging.onEmail(incomingEmail);    
   * \endcode
   *
   * Throws DeviceAPIError SECURITY_ERR if this operation is not allowed. 
   *
   * Throws DeviceAPIError NOT_SUPPORTED_ERR if this feature is not supported. 
   *
   * Throws DeviceAPIError INVALID_VALUES_ERR if the messageHandler is null or undefined. 
   *
   * Throws DeviceAPIError TYPE_MISMATCH_ERR if any input parameter is not compatible with the expected type for that parameter. 
   *
   * \param messageHandler he function to be invoked on incoming emails 
   * \return Subscription identifier 
   */                          
    unsigned long onEmail(OnIncomingMessage messageHandler) ;
                        
   
   /**                       
   * \brief Registers the function to be notified on incoming new Instant Message
   *
   * When this method is invoked, the implementation MUST register the function passed in the messageHandler argument as the handler for being notified whenever an incoming instant message arrives to the device. That function will be invoked every time an incoming Instant Message arrives, unless the unsubscribe method with the handler identifier is invoked in order to cancel the subscription.
   *
   * If the subscription is successfully created, an identifier for the handler is created and returned so that it is possible to cancel the subscription. If the subscription cannot be created, a DeviceAPIError is synchronously thrown with an error code that describes the reason for the error.
   *
   * \code
   * // function to receive new Instant Messaging notifications
   *  function incomingIM(message)
   *  {
   *    alert("New incoming Instant Message from " + message.from);
   * 
   *    // The subscription is cancelled to prevent further notifications
   *    if (myIMListener != null)
   *      deviceapis.messaging.unsubscribe(myIMistener);
   *  }
   * 
   *  // Register listener for new Instant Messaging events
   *  var myIMistener = null;
   *  myIMistener = deviceapis.messaging.onIM(incomingIM);    
   * \endcode
   *
   * Throws DeviceAPIError SECURITY_ERR if this operation is not allowed. 
   *
   * Throws DeviceAPIError NOT_SUPPORTED_ERR if this feature is not supported. 
   *
   * Throws DeviceAPIError INVALID_VALUES_ERR if the messageHandler is null or undefined. 
   *
   * Throws DeviceAPIError TYPE_MISMATCH_ERR if any input parameter is not compatible with the expected type for that parameter. 
   *
   * \param messageHandler he function to be invoked on incoming instant message 
   * \return Subscription identifier 
   */         
    unsigned long onIM(OnIncomingMessage messageHandler) ;

   /**                       
   * \brief Cancels a messaging subscription 
   *
   * If the subscriptionHandler argument is valid and corresponds to a subscription already in place the subscription process MUST immediately stop and no further message notifications MUST be invoked. If the subscriptionHandler argument does not correspond to a valid subscription, the method should return without any further action. 
   *
   * Throws DeviceAPIError TYPE_MISMATCH_ERR if any input parameter is not compatible with the expected type for that parameter. 
   *
   * \param subscriptionHandler identifier of the subscription returned by the onSMS(), onMMS(), onEmail() or onIM() methods. 
   * \return void
   */         
    void unsubscribe(unsigned long subscriptionHandler);                   
  };

   /**                       
   * \brief Defines the content and attributes of a message 
   *
   * This interface allows a web application to define the set of properties linked to a message previously created through the createMessage() method in the Messaging Interface.
   *
   * Additionally, it also allows an application to retrieve the content of a message through the findMessages, onSMS, onMMS and onEmail methods. In those cases, the implementation MAY return in some situations only part of the body because of its size. In those situations the implementation MUST allow the developer to retrieve the remaining part of the message through the use of the sync method member of the Synchronisable interface implemented by Message.
   *
   * Additionally, for the same reason, the implementation MAY decide to provide only the attachment information but not the attachment content. This is achieved by returning in the attachments attribute not a sequence of Files but a sequence of MessageAttachments (that implement the Synchronisable interface).
   *
   * If the developer attempts to access an attribute not supported by the messaging technology (see attribute description or summary table in the sendMessage mehtod description), the implementation MUST ignore this attempt.
   *
   * \code
   * var msg = deviceapis.messaging.createMessage(deviceapis.messaging.TYPE_SMS);
   * msg.body = "WAC first SMS message.";
   * msg.to = ["+34666666666"];
   * \endcode
   */           
    [NoInterfaceObject] interface Message {

   /**
    * \brief Message unique identifier.
    *
    * A unique indicator for identifying a message.
    * 
    * This property is a locally unique and persistent id, assigned by the device or the web runtime environment. For new messages created using Messaging.createMessage(), the id is assigned on the first occasion that the message is processed by the underlying platform such as a call to send(). This property is unique across device power cycles.
    */
    readonly attribute DOMString id;

   /**
    * \brief The type of the given message. 
    */
    attribute short type;
    
   /**
    * \brief  The folder for the given message.
    *
    *    For messages created through the createMessage method this property is undefined.
    */
    attribute short folder;
    
   /**
    * \brief The timestamp of a message.
    *
    * This property is set up by the device or the web runtime environment.
    */
    readonly attribute Date timestamp;
    
   /**
    * \brief The source address of a message.
    *
    * This property is set up by the device or the web runtime environment. This property should only be taken into account for Email.
    */
    readonly attribute DOMString from;

   /**
    * \brief The destination of a message. 
    */
    attribute StringArray to;
    
   /**
    * \brief The Cc address of a message. 
    */
    attribute StringArray cc;
    
   /**
    * \brief The Bcc address of a message. 
    */
    attribute StringArray bcc;

   /**
    * \brief The body of a message. 
    */
    attribute DOMString body;

   /**
    * \brief     The flag "read" for this Message.
    *
    * True if the message has been read and false otherwise.
    */
    attribute boolean isRead;

   /**
    * \brief     The priority of a message.
    *
    * True means high priority and false normal or low priority. This property should only be taken into account for Email.
    */
    attribute boolean priority;

   /**
    * \brief     The subject of a message.
    *
    * This property should only be taken into account for MMS and Email.
    */
    attribute DOMString subject;

   /**
    * \brief     The list of message attachments.
    *
    * This property should only be taken into account for Email and MMS. If the message has not been created by the developer but returned through the findMessage, onMMS or onEmail methods, the attachments will be stored in the "attachments" file system root location, that is only accessible through this API.
    */
    attribute FileArray attachments;


   /**                       
   * \brief Updates a message retrieved with the findMessages method 
   *
   * This method is meant to transfer all changes made to the given Message object before (i.e. changed attributes) to the underlying system (e.g. native messaging database and LDAP). If any changes cannot be transferred to the system, they can be ignored by the implementation.
   * 
   * This method does not have effect on messages created through the createMessage method as they are not persistenly stored until the send action is invoked.
   * 
   * For messages in the inbox (deviceapis.messaging.FOLDER_INBOX), outbox (deviceapis.messaging.FOLDER_OUTBOX) and sentbox (deviceapis.messaging.FOLDER_SENTBOX) the implementation MUST only change the isRead attribute of the Message object. For messages within the draft folder (deviceapis.messaging.FOLDER_DRAFTS) the implementation MAY update other attributes as well. However, this is up to the actual implementation and relies on the underlying system.
   * 
   * The implementation has to make sure that an updated Message object is provided in the success callback, which represents the current status of the message. The developer is expected to use this updated message for comparison with the former object to check which fields have or have not been transferred by the implementation.
   * 
   * If any of the input parameters is not compatible with the expected type for that parameter a DeviceAPIError with code TYPE_MISMATCH_ERR MUST be synchronously thrown.
   * 
   * If this feature is not supported, a DeviceAPIError with code NOT_SUPPORTED_ERR MUST be returned in the errorCallback. If this functionality is not allowed the errorCallback MUST be invoked with a DeviceAPIError with code SECURITY_ERR.
   * 
   * If the successCallback contains an invalid value (e.g. null or undefined), a DeviceAPIError with code INVALID_VALUES_ERR MUST be returned.
   * 
   * If any other error occurs, while trying to update the messages, the errorCallback function that was passed in the invocation MUST be called including a DeviceAPIError object with code UNKNOWN_ERR.
   * 
   * If the errorCallback does not contain a valid function (e.g. null), case of any error that should be returned in the errorCallback (see above), the implementation MUST silently fail and no further action is required (i.e. the error is not notified to the developer).
   *
   * Throws DeviceAPIError TYPE_MISMATCH_ERR if any input parameter is not compatible with the expected type for that parameter. 
   *
   * \param successCallback Function to call on successful update
   * \param errorCallback Function to call on unsuccessful update
   * \return PendingOperation to cancel the asynchronous call 
   */         
    
    PendingOperation update(UpdateMessageSuccessCallback successCallback, 
                            optional ErrorCallback errorCallback);
  };
  
  Message implements Synchronisable;

   /**                       
   * \brief Filter to restrict the items returned by the findMessages method 
   *
   * When used this filter in the findMessages operation, the result-set of the search MUST only contain the Message entries that match the filter values.
   *
   * An entry matches the filter, if the attributes of the entry matches all the attributes of the filter with values different to undefined or null. I.e. the search is performed in a similar manner to a SQL "AND" operation.
   * 
   * An attribute of the Message entry matches the filter value according to the following rules:
   * 
   *     For filter attributes of type DOMString an entry matches this value if its corresponding attribute is exactly the same than the filter one unless the filter contains U+0025 'PERCENT SIGN' wildcard character(s). If wildcards are used, the behavior is similar to the LIKE condition in SQL ('%' matches any string of any length - including zero length). In order to specify that a 'PERCENT SIGN' character is to be considered literally instead of interpreting it as a wildcard, developers may escape 
   * it with the backslash character.
   *    
   *  For filter attributes of type StringArray the same rules as for filter attributes of type DOMString apply for each of the fields within the given Array separately. The search for all included fields is performed similar to a SQL "AND" operation in the end without taking into account the (possible) difference in ordering between Message fields as well as MessageFilter fields.
   * 
   *  For filter attributes of an array of WebIDL numeric type (type), an entry matches it only if the corresponding entry attribute has exactly the same value as any of the array elements.
   * 
   *  For filter attributes of any WebIDL boolean type (isRead, messagePriority) an entry matches it only if the corresponding entry attribute has exactly the same state (i.e. true or false).
   * 
   *  For message attributes of type Date (i.e. timestamp), a couple of filter attributes are included (initial and end), order to allow looking for messages between two dates. If both initial and end dates are different to null, a message matches the filter if its corresponding attribute is between initial and end dates (including them). If only the initial date contains a value different to null, a message matches the filter if its corresponding attribute is later 
   *  than or equal to the initial one. If only the end date contains a value different to null, a message matches the filter if its corresponding attribute is earlier than or equal to the end date.
   *
   */           
  [Callback, NoInterfaceObject] interface MessageFilter {
   /**
    * \brief     Used for filtering the Message id attribute.
    *
    * Messages which id corresponds with this attribute (either exactly or with the specified wildcards) match this filtering criteria.
    */
    attribute DOMString id;

   /**
    * \brief     Used for filtering the Message type attribute.
    *
    * Messages with type equals to one of the values in this array match the filtering criteria.
    */
    attribute ShortArray type;
  
   /**
    * \brief     Used for filtering the Message folder attribute.
    *
    * Messages with folder equals to one of the values in this array match the filtering criteria.
    */
    attribute ShortArray folder;

   /**
    * \brief     Used for filtering the Message timestamp attribute.
    *
    * Messages with date later than or equal to this attribute match the filtering criteria.
    */
    attribute Date startTimestamp;

   /**
    * \brief     Used for filtering the Message timestamp attribute.
    *
    * Messages with date earlier than or equal to this attribute match the filtering criteria.
    */
    attribute Date endTimestamp;
    
   /**
    * \brief     Used for filtering the Message from attribute.
    *
    * Messages which from corresponds with this attribute (either exactly or with the specified wildcards) match this filtering criteria.
    */
    attribute DOMString from;

   /**
    * \brief     Used for filtering the Message to attribute.
    *
    * Messages which elements in the to array that correspond to all the elements of this attribute (either exactly or with the specified wildcards) match this filtering criteria.
    */
    attribute StringArray to;
    
   /**
    * \brief     Used for filtering the Message cc attribute.
    *
    * Messages which elements in the cc array that correspond to all the elements of this attribute (either exactly or with the specified wildcards) match this filtering criteria.
    */
    attribute StringArray cc;
    
   /**
    * \brief     Used for filtering the Message bcc attribute.
    *
    * Messages which elements in the bcc array that correspond to all the elements of this attribute (either exactly or with the specified wildcards) match this filtering criteria.
    */
    attribute StringArray bcc;

   /**
    * \brief     Used for filtering the Message body attribute.
    *
    * Messages which body corresponds with this attribute (either exactly or with the specified wildcards) match this filtering criteria.
    */
    attribute DOMString body;

   /**
    * \brief     Used for filtering the Message isRead attribute.
    *
    * Messages which isRead corresponds exactly with this attribute match this filtering criteria.
    */
    attribute boolean isRead;

   /**
    * \brief     Used for filtering the Message messagePriority attribute.
    *
    * Messages which messagePriority corresponds exactly with this attribute match this filtering criteria.
    */
    attribute boolean messagePriority;

   /**
    * \brief     Used for filtering the Message subject attribute.
    *
    * Messages which subject corresponds with this attribute (either exactly or with the specified wildcards) match this filtering criteria.
    */
    attribute DOMString subject;
  };
  
   /**                       
   * \brief Describes a message attachement 
   *
   * This attribute extends the File interface (from W3C File reader (http://dev.w3.org/2006/webapi/FileAPI/#file)) by concurrently implementing the synchronizable interface. It allows attachments to be downloaded only if the user requests them by the use of the sync method specified in the Synchronizable interface. 
   *
   */           
  
    interface MessageAttachment : File {
   /**
    * \brief    Describes the mime type of the attachment, e.g. "text/html". 
    *
    */  
    readonly attribute DOMString MIMEType; 
  };
  
  
   /**                       
   * \brief findMessages specific success callback. 
   *
   * This callback interface specifies a success callback with a function taking a list of messages as input argument. It is used in the findMessages asynchronous operation. 
   *
   */           
  [Callback=FunctionOnly, NoInterfaceObject] interface FindMessagesSuccessCallback {
   /**                       
   * \brief Method invoked when the asynchronous call completes successfully 
   *
   * \param messages The list of messages that correspond to the find criteria 
   * \return void
   */         
    void onsuccess(MessageArray messages);
  };
  
   /**                       
   * \brief update specific success callback. 
   *
   * This callback interface specifies a success callback with a function that will provide a message object that is meant to represent the actual status of a message after an update has been triggered. It is used in the update asynchronous operation on the Message interface. 
   *
   */           
  [Callback=FunctionOnly, NoInterfaceObject] interface UpdateMessageSuccessCallback {
   /**                       
   * \brief Method invoked when the asynchronous call completes successfully 
   *
   * \param message The new message representing the actual updated status 
   * \return void
   */         
    void onsuccess(Message message);
  };

   /**                       
   * \brief Interface for specifying the method called on new incoming message events. 
   *
   * This interface specifies a function that will provide a message object that represents the received message. It is used in the onSMS(), onMMS(), onEmail() method invocation. 
   *
   */           
  [Callback=FunctionOnly, NoInterfaceObject] interface OnIncomingMessage {
   /**                       
   * \brief Method invoked when an incoming message is received 
   *
   * \param message The message received 
   * \return void
   */         
     void onevent (Message message);
  };

   /**                       
   * \brief Interface for specifying the methods to be called for message send results for each recipient. 
   *
   * This interface specifies a set of functions that will be invoked every time the result of the send operation to a recipient is obtained or when the message is successfully sent to all the recipients. 
   *
   */           
  [Callback, NoInterfaceObject] interface MessageSendCallback {
   /**                       
   * \brief Method invoked when the message is successfully sent to all the recipients 
   *
   * \return void
   */         
     void onsuccess();

   /**                       
   * \brief Method invoked when the message is successfully sent to a recipient 
   *
   * \param recipient The recipient which the message has been sent to 
   * \return void
   */         
     void onmessagesendsuccess(DOMString recipient);

   /**                       
   * \brief Method invoked when the message is unsuccessfully sent to a recipient 
   *
   * \param error The error code that identifies the reason of the failure 
   * \param recipient The recipient which the message has been sent to 
   * \return void
   */         
     void onmessagesenderror(DeviceAPIError error, DOMString recipient);
  };
  
      /**
     * \brief The PendingOperation interface
     *
     * The PendingOperation interface describes operation of cancellable aynchronous methods.
     * Cancellable asynchronous methods return PendingOperation objects exporting methods for
     * cancelling the operation. 
     *
     */
     [NoInterfaceObject] interface PendingOperation {

    /**
     * \brief Cancel method for cancelling asynchronous operation
     *
     *  Cancel ongoing asynchronous method call. Upon calling this method the runtime must immediately stop
     *  the pending operation and return.
     */
        void cancel ();
     };

